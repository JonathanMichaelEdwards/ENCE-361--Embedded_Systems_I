//  ==========================================================================
//  ENCE-361: Embedded Systems 1 (2020);  University of Canterbury
//  Project:  Personal Fitness Monitor Project - Milestone 1 
//
//  FILE NAME:     main.c
//  
//  Authors:       P.J. Bones  UCECE department, Grace Kaye-Blake,
//                 Jonathan Edwards, Riley Symon
// 
//  Description:   Milestone 1 involves generating a TIVA program to read data 
//                 from the Orbit boardâ€™s three-axis accelerometer and display 
//                 that data on the OLED display.
//  ==========================================================================


// Standard libaries
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>

// Arm Libaries
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/adc.h"
#include "driverlib/pwm.h"
#include "driverlib/gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/interrupt.h"
#include "driverlib/debug.h"
#include "driverlib/uart.h"
#include "utils/ustdlib.h"

// Project Libaries - created by us
//#include "initialize.h"
#include "circBufT.h"
#include "display.h"
#include "buttons4.h"
#include "acc.h"

#include "FSM_MVC/model.h"
#include "normalMode.h"


// Constants
#define CLOCK_20MHZ         20e6
#define SYSTICK_RATE_HZ     50
#define SLOWTICK_RATE_HZ    10
#define MAX_STR_LEN         16

// Global Varibles - ISR globals
static bool slowTick;



// -----------------------------------------------------------------------------
//                           Initialize the 20 MHz clock                           
// -----------------------------------------------------------------------------
void initClock(void)
{
    // Set the clock rate to 20 MHz
    SysCtlClockSet (SYSCTL_SYSDIV_10 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN |
                   SYSCTL_XTAL_16MHZ);
}


// -----------------------------------------------------------------------------
//                 ISR interrupt handler for the SysTick interrupt
// -----------------------------------------------------------------------------
void SysTickIntHandler(void)
{
    static uint8_t tickCount = 0;
    const uint8_t ticksPerSlow = SYSTICK_RATE_HZ / SLOWTICK_RATE_HZ;

    updateButtons ();                      // Poll buttons
    if (++tickCount >= ticksPerSlow) {     // Signal slow ticks
        tickCount = 0;
        slowTick = true;
    }
}


// -----------------------------------------------------------------------------
//                       Initialize the Interrupt Handler                       
// -----------------------------------------------------------------------------
void initSysTick(void)
{
    // Set up the period for the SysTick timer.  The SysTick timer period is
    // set as a function of the system clock.
    SysTickPeriodSet(CLOCK_20MHZ / SYSTICK_RATE_HZ);
    
    // Register the interrupt handler
    SysTickIntRegister(SysTickIntHandler);
    
    // Enable interrupt and device
    SysTickIntEnable();
    SysTickEnable();
}


bool startMonitor()   
{
    return 0;
}


bool resetMonitor()
{
    return 0;
}



/** -----------------------------------------------------------------------------
//                              Initialize Everything    
// 
// @param ptr_circBuff - Initialize x, y and z directions in a circular buffer
// ---------------------------------------------------------------------------*/
void init(CircBuff *circBuff)
{
    initClock();
    initSysTick();
    initButtons();
    initDisplay();

    // Initialise circBuf
    initCircBuf(&circBuff->x, BUF_SIZE);
    initCircBuf(&circBuff->y, BUF_SIZE);
    initCircBuf(&circBuff->z, BUF_SIZE);

    initI2C();
    initAccl();
}


// -----------------------------------------------------------------------------
//                              Executes the program                           
// -----------------------------------------------------------------------------
int main(void)
{
    // Stored structures
    Acc acc = {0};
    RefAcc refAcc = {0};
    CircBuff circBuff = {0};

    uint8_t samplesBuffered = 0;   // Number of samples buffered
    uint8_t unitState = 0;         // Unit display state

    uint32_t accSamples = 0;       // Number of samples taken





/////////////////////////// part 2

enum swModes { NORMAL=0, TEST };


    // calculations stored in a pointer 
    uint32_t steps = 0;
    uint32_t distance = 0;

    // state of the FSM
    uint8_t btnName = -1;
    uint8_t btnState = -1;

    // toggle mode
    bool mode = NORMAL;  // 0 = normal (startup - SW = down),  1 = test (SW = up)


/////////////////////////////////


    init(&circBuff);

    while (1) {




///////////////////////////////////////// part 2

// 1.
    // check the mode of the switch;
    // chkSwitch()

// btnName:          UP = 0, DOWN, LEFT, RIGHT, NUM_BUTS
// butStates:        RELEASED = 0, PUSHED, NO_CHANGE   

// 2.
    if (!mode)   // Normal mode
        normalMode(btnName, btnState, steps, distance);
    else        // Test mode
        // testMode(btnName, btnState, steps, distance);
       
       
       
        // normalMode(bool mode, uint8_t btnName, uint8_t btnState, uint32_t steps, uint32_t distance);

/////////////////////////////////





        if (checkButton(UP) == PUSHED) {
            unitState++;
            if (unitState == 3) { unitState = 0; }
        } else if (checkButton(DOWN) == PUSHED) {
            refAcc = buffMean(&circBuff, refAcc, samplesBuffered);
        }

        if (slowTick) {
            slowTick = false;  // Change ISR flag

            // Read raw values from accelerometer
            getAccelData(&acc.x, &acc.y, &acc.z);

            // Write accelerometer values to each individual buffer
            circBuff = writeBuff(circBuff, acc);
            samplesBuffered++;
            if (samplesBuffered > BUF_SIZE) {
                samplesBuffered = BUF_SIZE;
            }

            // Update accelerometer values
            acc.x = getCircBufMean(&(circBuff.x), samplesBuffered);
            acc.y = getCircBufMean(&(circBuff.y), samplesBuffered);
            acc.z = getCircBufMean(&(circBuff.z), samplesBuffered);


            acc = accUpdate(acc, &accSamples, unitState);


            if (accSamples == BUF_SIZE) {
                refAcc = buffMean(&circBuff, refAcc, samplesBuffered);
            }
        }
    }
}
