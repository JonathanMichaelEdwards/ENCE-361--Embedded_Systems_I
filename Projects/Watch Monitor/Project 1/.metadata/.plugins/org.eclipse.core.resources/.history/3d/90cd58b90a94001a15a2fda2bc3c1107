//  ==========================================================================
//  ENCE-361: Embedded Systems 1 (2020);  University of Canterbury
//  Project:  Personal Fitness Monitor Project
//
//  FILE NAME:     model.c
//  
//  Authors:       P.J. Bones  UCECE department, Grace Kaye-Blake,
//                 Jonathan Edwards, Riley Symon
// 
//  Description:   
//  ==========================================================================


 // Standard libaries
 #include <stdint.h>
 #include <stdlib.h>
 #include <stdbool.h>

// Arm Libaries
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/adc.h"
#include "driverlib/pwm.h"
#include "driverlib/gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/interrupt.h"
#include "driverlib/debug.h"
#include "driverlib/uart.h"
#include "utils/ustdlib.h"

// Project Libaries - created by us
#include "FSM_MVC/model.h"
#include "circBufT.h"
#include "display.h"
#include "buttons4.h"
#include "acc.h"


// -- Global Varibles, defines and Structures --------------------------------------------------
enum units { RAW = 0, G = 1, MPSS = 2 };  // btn States


/** -----------------------------------------------------------------------------
//       Get the Circular Buffer means for x, y and z with their references 
// 
// @param ptr_circBuff - data about each circular buffer
// @param refAcc       - reference acceleration
// @param buffSamples  - buffer sample number
// 
// @return refAcc      - acceleration reference stored in a structure
// ---------------------------------------------------------------------------*/
RefAcc buffMean(CircBuff *circBuff, RefAcc refAcc, uint8_t buffSamples)
{
    refAcc.x = getCircBufMean(&circBuff->x, buffSamples);
    refAcc.y = getCircBufMean(&circBuff->y, buffSamples);
    refAcc.z = getCircBufMean(&circBuff->z, buffSamples);

    return refAcc;
}


/** -----------------------------------------------------------------------------
//       Write x, y and z accelerometer acceleration values to each of their
//                         individual circular buffers 
// 
// @param circBuff     - data about each circular buffer
// @param acc          - accelerometer data
// 
// @return circBuff    - updated data about each circular buffer
// ---------------------------------------------------------------------------*/
CircBuff writeBuff(CircBuff circBuff, Acc acc)
{
    writeCircBuf(&circBuff.x, acc.x);
    writeCircBuf(&circBuff.y, acc.y);
    writeCircBuf(&circBuff.z, acc.z);

    return circBuff;
}


/** -----------------------------------------------------------------------------
//       Display accelerometor information according to the btn state
// displays: raw acceleration -> acceleration in g -> acceleration in ms^-2
// 
// @param acc             - accelerometer data
// @param ptr_accSamples  - total amount of samples from the accelerometer
// @param state           - unit state program is in

// @return acc            - updated data about each circular buffer
// ---------------------------------------------------------------------------*/
Acc accUpdate(Acc acc, uint32_t *accSamples, uint32_t state)
{
    uint32_t _accSamples = *accSamples;  // temp sample value

    // x100 to acc.* to go from m -> cm (resolution) 
    acc.x = ((acc.x*GRAVITY*100) / ACCEL_SENSITVITY);
    acc.y = ((acc.y*GRAVITY*100) / ACCEL_SENSITVITY);
    acc.z = ((acc.z*GRAVITY*100) / ACCEL_SENSITVITY);

    *accSamples = _accSamples;  // pass temp sample back to original

    return acc;
}  


/** -----------------------------------------------------------------------------
//          Regularly update the mean values for the circular buffers
// 
// @param ptr_circBuff     - data about each circular buffer
// @param refAcc           - reference acceleration
// @param accSamples       - total amount of samples from the accelerometer
// @param buffSamples      - buffer sample number

// @return refAcc          - acceleration reference stored in a structure
// ---------------------------------------------------------------------------*/
RefAcc meanUpdate(CircBuff *circBuff, RefAcc refAcc, uint32_t accSamples, uint8_t buffSamples)
{
    // to fulfil milestone 1: 1.2
    buffMean(circBuff, refAcc, buffSamples);

    // Update ref acc every mod BUF_SIZE
    if (accSamples % BUF_SIZE == 0 && accSamples >= BUF_SIZE) {
        // Set the reference values when the circular buffer is full
        // This is not done when the program is initiated, because
        // there would be no values to calculate a mean from
        refAcc = buffMean(circBuff, refAcc, buffSamples);
    }

    return refAcc;
}
