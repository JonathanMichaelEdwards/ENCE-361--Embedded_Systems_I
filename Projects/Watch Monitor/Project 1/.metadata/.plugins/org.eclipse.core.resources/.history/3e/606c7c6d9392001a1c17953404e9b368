//  ==========================================================================
//  ENCE-361: Embedded Systems 1 (2020);  University of Canterbury
//  Project:  Personal Fitness Monitor Project - Milestone 1 
//
//  FILE NAME:     main.c
//  
//  Authors:       P.J. Bones  UCECE department, Grace Kaye-Blake,
//                 Jonathan Edwards, Riley Symon
// 
//  Description:   Milestone 1 involves generating a TIVA program to read data 
//                 from the Orbit boardâ€™s three-axis accelerometer and display 
//                 that data on the OLED display.
//  ==========================================================================


// Standard libaries
#include <stdint.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>

// Arm Libaries
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/adc.h"
#include "driverlib/pwm.h"
#include "driverlib/gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/interrupt.h"
#include "driverlib/debug.h"
#include "driverlib/uart.h"
#include "utils/ustdlib.h"

// Project Libaries - created by us
//#include "initialize.h"
#include "circBufT.h"
#include "display.h"
#include "buttons4.h"
#include "acc.h"
#include "uart.h"
#include "delay.h"

#include "FSM_MVC/model.h"
#include "FSM_MVC/Modes/normalMode.h"


// Constants
#define CLOCK_20MHZ         20e6
#define SYSTICK_RATE_HZ     50
#define SLOWTICK_RATE_HZ    10
#define MAX_STR_LEN         16

#define NORM_1(ACC)         (abs(ACC.x) + abs(ACC.y) + abs(ACC.z)) + 0.5
#define NORM_2(ACC)         (sqrt((ACC.x)*(ACC.x) + (ACC.y)*(ACC.y) + (ACC.z)*(ACC.z))) + 0.5

// Global Varibles - ISR globals
static bool slowTick;



// -----------------------------------------------------------------------------
//                           Initialize the 20 MHz clock                           
// -----------------------------------------------------------------------------
void initClock(void)
{
    // Set the clock rate to 20 MHz
    SysCtlClockSet (SYSCTL_SYSDIV_10 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN |
                   SYSCTL_XTAL_16MHZ);
}


// -----------------------------------------------------------------------------
//                 ISR interrupt handler for the SysTick interrupt
// -----------------------------------------------------------------------------
void SysTickIntHandler(void)
{
    static uint8_t tickCount = 0;
    const uint8_t ticksPerSlow = SYSTICK_RATE_HZ / SLOWTICK_RATE_HZ;

    updateButtons ();                      // Poll buttons
    if (++tickCount >= ticksPerSlow) {     // Signal slow ticks
        tickCount = 0;
        slowTick = true;
    }
}


// -----------------------------------------------------------------------------
//                       Initialize the Interrupt Handler                       
// -----------------------------------------------------------------------------
void initSysTick(void)
{
    // Set up the period for the SysTick timer.  The SysTick timer period is
    // set as a function of the system clock.
    SysTickPeriodSet(CLOCK_20MHZ / SYSTICK_RATE_HZ);
    
    // Register the interrupt handler
    SysTickIntRegister(SysTickIntHandler);
    
    // Enable interrupt and device
    SysTickIntEnable();
    SysTickEnable();
}


bool startMonitor()   
{
    return 0;
}


bool resetMonitor()
{
    return 0;
}



/** -----------------------------------------------------------------------------
//                              Initialize Everything    
// 
// @param ptr_circBuff - Initialize x, y and z directions in a circular buffer
// ---------------------------------------------------------------------------*/
void init(CircBuff *circBuff)
{
    initClock();
    initSysTick();
    initButtons();
    initDisplay();

    // Initialise circBuf
    initCircBuf(&circBuff->x, BUF_SIZE);
    initCircBuf(&circBuff->y, BUF_SIZE);
    initCircBuf(&circBuff->z, BUF_SIZE);

    initI2C();
    initAccl();
}


// -----------------------------------------------------------------------------
//                              Executes the program                           
// -----------------------------------------------------------------------------
int main(void)
{
    // Stored structures
    Acc acc = { 0 };
    RefAcc refAcc = { 0 };
    CircBuff circBuff = { 0 };

    uint8_t samplesBuffered = 0;   // Number of samples buffered
    uint8_t unitState = 2;         // Unit display state                                ------------- change code

    uint32_t accSamples = 0;       // Number of samples taken





/////////////////////////// part 2 ---------------------------------------------

    enum swModes { NORMAL=0, TEST };

    // calculations stored in a pointer(s)
    uint32_t stepCount = 0;
    uint8_t dbStepCount = 0;
    bool detectCount = false;

    uint32_t distance = 0;

    // state of the FSM
    uint8_t btnName = NUM_BUTS;
    uint8_t btnState = NO_CHANGE;

// btnName:          UP = 0, DOWN, LEFT, RIGHT, NUM_BUTS
// butStates:        RELEASED = 0, PUSHED, NO_CHANGE   

    // toggle mode - Switch
    bool mode = NORMAL;  // 0 = normal (startup - SW = down),  1 = test (SW = up)


///////////////////////////////// ---------------------------------------------



    // initialize tiva board
    init(&circBuff);

    while (1) {


        // chk btn states  ---------------------------------------------
        if (checkButton(UP) == PUSHED) {                             // btn=UP: Change unit state
            unitState++;
            if (unitState == 3) unitState = 0;
        } else if (checkButton(DOWN) == PUSHED) {                    // btn=DOWN: Update ref value  (reference point change)
            refAcc = buffMean(&circBuff, refAcc, samplesBuffered);  
            refAcc.norm = NORM_1(refAcc);
            // set debug point here for test - program runs then when btn pushed - prg halts
        }
        // ---------------------------------------------


        // ISR - get Accelerometer data ---------------------------------------------
        if (slowTick) {
            slowTick = false;  // Change ISR flag

            // Read raw values from accelerometer
            getAccelData(&acc.x, &acc.y, &acc.z);

            // Write accelerometer values to each individual buffer
            circBuff = writeBuff(circBuff, acc);
            samplesBuffered++;
            if (samplesBuffered > BUF_SIZE) {
                samplesBuffered = BUF_SIZE;
            }

            // Update accelerometer values
            acc.x = getCircBufMean(&(circBuff.x), samplesBuffered);
            acc.y = getCircBufMean(&(circBuff.y), samplesBuffered);
            acc.z = getCircBufMean(&(circBuff.z), samplesBuffered);

            // Update display & conversions accelerometer
            acc = accUpdate(acc, &accSamples, unitState);

// ------------------------------------------------------------------------------------
            acc.currNorm = NORM_1(acc);
            // acc.currNorm = NORM_2(acc);
            // float a = (sqrt((acc.x)*(acc.x) + (acc.y)*(acc.y) + (acc.z)*(acc.z)));//NORM_2(acc)*100;


// //////////////////// -------------- trial 1 -----------------------------
//             // Check to see if a step was taken ----------------------------
//             if ((acc.currNorm*10) > (int32_t)((1.5*10)*(GRAVITY*100)) && !detectCount) { 
//                detectCount = true;
//             //    dbStepCount++;
//             } else if (detectCount) {  // When not in thresh hold area and was previosly detected - incr step count
//                 // int i = 0;
//                 // delayMilli(300);  // debounce signal
//                 if (350 < abs(acc.currNorm-acc.prvNorm)) { // Debouncing Norms (Improve!!!) -- chk difference
//                     // for (; i < 400; i++);
//                     stepCount++;
//                     detectCount = false;
//                     // dbStepCount = 0;
//                 }
//             }
//             acc.prvNorm = acc.currNorm;
// //////////////////// -------------- trial 1 -----------------------------




            // Check to see if a step was taken ----------------------------
            if ((acc.currNorm*10) > (int32_t)((1.5*10)*(GRAVITY*100))) { 
                detectCount = true;
            } else if (detectCount) {  // When not in thresh hold and previosly detected - incr step
                if (425 < abs(acc.currNorm-acc.prvNorm)) { // Debouncing Norms (Improve!!!) -- chk difference
                    stepCount++;
                    detectCount = false;
                }
            }
            acc.prvNorm = acc.currNorm;



            char string[17];
            usnprintf(string, sizeof(string), "steps: %5d", stepCount);
            OLEDStringDraw(string, 0, 3);


// ------------------------------------------------------------------------------------




            ////////////// mil - 1
            // Find initial ref accelerometer values
            if (accSamples == BUF_SIZE) {
                refAcc = buffMean(&circBuff, refAcc, samplesBuffered);
                refAcc.norm = NORM_1(refAcc);
            }

            ////////////// mil - 1
        }
        // ---------------------------------------------



        ///////////////////////////////////////// part 2 ---------------------------------------------

// 1. - SWITCH (SW 1)
    // check the mode of the switch;
    // i.e chkSwitch()

    if (!mode)   // Normal mode
        normalMode(&btnName, &btnState, &stepCount, &distance);
    else        // Test mode
        testMode(&btnName, &btnState, &stepCount, &distance);
       
       
       
        // normalMode(bool mode, uint8_t btnName, uint8_t btnState, uint32_t steps, uint32_t distance);

///////////////////////////////// ---------------------------------------------



    }
}
