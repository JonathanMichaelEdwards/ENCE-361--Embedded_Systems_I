//*****************************************************************************
//
// Authors:  P.J. Bones  UCECE Grace Kaye-Blake, Jonathan Edwards, Riley Symon
//
//*****************************************************************************

#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/adc.h"
#include "driverlib/pwm.h"
#include "driverlib/gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/interrupt.h"
#include "driverlib/debug.h"
#include "utils/ustdlib.h"
#include "circBufT.h"
#include "driverlib/uart.h"
#include "OrbitOLED/OrbitOLEDInterface.h"

#include "display.h"
#include "buttons4.h"
#include "delay.h"
#include "acc.h"

#define SYSTICK_RATE_HZ 50
#define SLOWTICK_RATE_HZ 10
#define MAX_STR_LEN 16

enum units { RAW = 0, G = 1, MPSS = 2 };

void SysTickIntHandler (void);
void initSysTick (void);
uint8_t slowTick;

void
initClock (void)
{
    // Set the clock rate to 20 MHz
    SysCtlClockSet (SYSCTL_SYSDIV_10 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN |
                   SYSCTL_XTAL_16MHZ);
}

void
SysTickIntHandler (void)
{
    static uint8_t tickCount = 0;
    const uint8_t ticksPerSlow = SYSTICK_RATE_HZ / SLOWTICK_RATE_HZ;

    updateButtons ();       // Poll the buttons
    if (++tickCount >= ticksPerSlow)
    {                       // Signal a slow tick
        tickCount = 0;
        slowTick = true;
    }
}

void
initSysTick (void)
{
    //
    // Set up the period for the SysTick timer.  The SysTick timer period is
    // set as a function of the system clock.
    SysTickPeriodSet (SysCtlClockGet () / SYSTICK_RATE_HZ);
    //
    // Register the interrupt handler
    SysTickIntRegister (SysTickIntHandler);
    //
    // Enable interrupt and device
    SysTickIntEnable ();
    SysTickEnable ();
}

int main(void)
{
    uint16_t i;
    int32_t sum;

    int32_t accX = 0;
    int32_t accY = 0;
    int32_t accZ = 0;

    // These store the reference values
    int32_t refAccX = 0;
    int32_t refAccY = 0;
    int32_t refAccZ = 0;

    uint32_t accSamples = 0; //Number of samples taken
    uint8_t samplesBuffered = 0; //Number of samples buffered

    uint8_t butState;
    uint8_t unitState; //The state of the units of the display

    // The three circular buffers
    circBuf_t intBufferX;
    circBuf_t intBufferY;
    circBuf_t intBufferZ;

    initClock();
    initSysTick ();
    initButtons();
    initDisplay();
    initCircBuf(&intBufferX, BUF_SIZE);
    initCircBuf(&intBufferY, BUF_SIZE);
    initCircBuf(&intBufferZ, BUF_SIZE);
    initI2C();
    initAccl();

    while (1) {

        //Poll the buttons
//        updateButtons();
////        butState = checkButton (UP);
////        if (butState == PUSHED) {
////        butState = checkButton (UP);
//        if (checkButton (UP) == PUSHED) {
//            unitState++;
//            if (unitState == 3) {unitState = 0;}
//        }
////        butState = checkButton (DOWN);
//        else if (checkButton (DOWN) == PUSHED) {
//            refAccX = getCircBufMean(&intBufferX, samplesBuffered);
//            refAccY = getCircBufMean(&intBufferY, samplesBuffered);
//            refAccZ = getCircBufMean(&intBufferZ, samplesBuffered);
//        }

        butState = checkButton (UP);
        switch (butState)
        {
        case PUSHED:
            unitState++;
            if (unitState == 3) unitState = 0;
            break;
//        case RELEASED:
//            displayButtonState ("UP  ", "RELS", upPushes, 2);
//            break;
        // Do nothing if state is NO_CHANGE
        }

        butState = checkButton (DOWN);
        switch (butState)
        {
        case PUSHED:
            refAccX = getCircBufMean(&intBufferX, samplesBuffered);
            refAccY = getCircBufMean(&intBufferY, samplesBuffered);
            refAccZ = getCircBufMean(&intBufferZ, samplesBuffered);
            break;
//        case RELEASED:
//            displayButtonState ("DOWN", "RELS", downPushes, 3);
//            break;
        // Do nothing if state is NO_CHANGE
        }



        if (slowTick) {
            slowTick = false;

            // Read from the accelerometer and write the values to the buffers
            getAccelData(&accX, &accY, &accZ);
            writeCircBuf (&intBufferX, accX);
            writeCircBuf (&intBufferY, accY);
            writeCircBuf (&intBufferZ, accZ);
            samplesBuffered++;
            if (samplesBuffered > BUF_SIZE) {
                samplesBuffered = BUF_SIZE;
            }

            // Update the display
            switch (unitState) {
            case MPSS:
                accX = accX * GRAVITY;
                accY = accY * GRAVITY;
                accZ = accZ * GRAVITY;
            case G:
                accX = accX * 100 / ACCEL_SENSITVITY;
                accY = accY * 100 / ACCEL_SENSITVITY;
                accZ = accZ * 100 / ACCEL_SENSITVITY;
                displayMeanValf(accX, accY, accZ, ++accSamples);
            break;
            case RAW:
                displayMeanVal(accX, accY, accZ, ++accSamples);
            }
//            delayMilli(500); // Update display at ~ 2 Hz                       ********************* added

            //to fulfil milestone 1.2
//            getCircBufMean(&intBufferX, samplesBuffered);
//            getCircBufMean(&intBufferY, samplesBuffered);
//            getCircBufMean(&intBufferZ, samplesBuffered);
//
//            if (accSamples == BUF_SIZE) {
//                // Set the reference values when the circular buffer is full
//                // This is not done when the program is initiated, because
//                // there would be no values to calculate a mean from
//                refAccX = getCircBufMean(&intBufferX, samplesBuffered);
//                refAccY = getCircBufMean(&intBufferY, samplesBuffered);
//                refAccZ = getCircBufMean(&intBufferZ, samplesBuffered);
//            }

            sum = 0;
            for (i = 0; i < BUF_SIZE; i++)
                sum = sum + readCircBuf (&g_inBuffer);
        }
    }
}

