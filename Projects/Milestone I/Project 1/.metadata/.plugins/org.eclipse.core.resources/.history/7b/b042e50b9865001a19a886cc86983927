//  ==========================================================================
//  ENCE-361: Embedded Systems 1 (2020);  University of Canterbury
//  Project:  Personal Fitness Monitor Project - Milestone 1 
//
//  FILE NAME:     main.c
//  
//  Authors:       P.J. Bones  UCECE department, Grace Kaye-Blake,
//                 Jonathan Edwards, Riley Symon
// 
//  Description:   Milestone 1 involves generating a TIVA program to read data 
//                 from the Orbit boardâ€™s three-axis accelerometer and display 
//                 that data on the OLED display.
//  ==========================================================================


// Standard libaries
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>

// Arm Libaries
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/adc.h"
#include "driverlib/pwm.h"
#include "driverlib/gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/interrupt.h"
#include "driverlib/debug.h"
#include "driverlib/uart.h"
#include "utils/ustdlib.h"

// Project Libaries - created by us
#include "circBufT.h"
#include "display.h"
#include "buttons4.h"
#include "acc.h"


// Constants
#define CLOCK_20MHZ         20000000
#define SYSTICK_RATE_HZ     50
#define SLOWTICK_RATE_HZ    10
#define MAX_STR_LEN         16


// Global Varibles and objects
uint8_t slowTick;
enum units { RAW = 0, G = 1, MPSS = 2 };  // btn States

typedef struct _Acc {
    int32_t x;
    int32_t y;
    int32_t z;
} Acc;

typedef struct _RefAcc {
    int32_t x;
    int32_t y;
    int32_t z;
} RefAcc;

typedef struct _CircBuff {
    circBuf_t x;
    circBuf_t y;
    circBuf_t z;
} CircBuff;


// -----------------------------------------------------------------------------
//                           Initialize the 20 MHz clock                           
// -----------------------------------------------------------------------------
void initClock(void)
{
    // Set the clock rate to 20 MHz
    SysCtlClockSet (SYSCTL_SYSDIV_10 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN |
                   SYSCTL_XTAL_16MHZ);
}


// -----------------------------------------------------------------------------
//                   Interrupt handler for the SysTick interrupt
// -----------------------------------------------------------------------------
void SysTickIntHandler(void)
{
    static uint8_t tickCount = 0;
    const uint8_t ticksPerSlow = SYSTICK_RATE_HZ / SLOWTICK_RATE_HZ;

    updateButtons ();                      // Poll buttons
    if (++tickCount >= ticksPerSlow) {     // Signal slow ticks
        tickCount = 0;
        slowTick = true;
    }
}


// -----------------------------------------------------------------------------
//                       Initialize the Interrupt Handler                       
// -----------------------------------------------------------------------------
void initSysTick(void)
{
    // Set up the period for the SysTick timer.  The SysTick timer period is
    // set as a function of the system clock.
    SysTickPeriodSet(CLOCK_20MHZ / SYSTICK_RATE_HZ);
    
    // Register the interrupt handler
    SysTickIntRegister(SysTickIntHandler);
    
    // Enable interrupt and device
    SysTickIntEnable();
    SysTickEnable();
}


/** -----------------------------------------------------------------------------
//                              Initialize Everything    
// 
// @param ptr_buffX - Initialize x-dir accel in a circular buffer
// @param ptr_buffY - Initialize y-dir accel in a circular buffer
// @param ptr_buffY - Initialize z-dir accel in a circular buffer
// ---------------------------------------------------------------------------*/
void init(CircBuff *circBuff)
{
    // circBuff = (CircBuff*)malloc(sizeof(CircBuff) * BUF_SIZE);

    initClock();
    initSysTick ();
    initButtons();
    initDisplay();

    // Initialise circBuf
    initCircBuf(&circBuff->x, BUF_SIZE);
    initCircBuf(&circBuff->y, BUF_SIZE);
    initCircBuf(&circBuff->z, BUF_SIZE);

    initI2C();
    initAccl();
}


// /** -----------------------------------------------------------------------------
// //                              Initialize Everything    
// // 
// // @param ptr_buffX - Initialize x-dir accel in a circular buffer
// // @param ptr_buffY - Initialize y-dir accel in a circular buffer
// // @param ptr_buffY - Initialize z-dir accel in a circular buffer
// // ---------------------------------------------------------------------------*/
// void init(circBuf_t *intBuffX, circBuf_t *intBuffY, circBuf_t *intBuffZ)
// {
//     initClock();
//     initSysTick ();
//     initButtons();
//     initDisplay();

//     // Initialise circBuf
//     initCircBuf(intBuffX, BUF_SIZE);
//     initCircBuf(intBuffY, BUF_SIZE);
//     initCircBuf(intBuffZ, BUF_SIZE);

//     initI2C();
//     initAccl();
// }



// getBuffMean()
// {
//     refAccX = getCircBufMean(&intBuffX, samplesBuffered);
//     refAccY = getCircBufMean(&intBuffY, samplesBuffered);
//     refAccZ = getCircBufMean(&intBuffZ, samplesBuffered);
// }

// typedef struct _Acc {
//     int32_t accX;
//     int32_t accY;
//     int32_t accZ;
// } Acc;

// typedef struct _RefAcc {
//     int32_t refAccX;
//     int32_t refAccY;
//     int32_t refAccZ;
// } RefAcc;

// typedef struct _CircBuff {
//     circBuf_t intBuffX;
//     circBuf_t intBuffY;
//     circBuf_t intBuffZ;
// } CircBuff;


RefAcc buffMean(CircBuff *circBuff, RefAcc refAcc, uint8_t buffSamples)
{
    refAcc.x = getCircBufMean(&circBuff->x, buffSamples);
    refAcc.y = getCircBufMean(&circBuff->y, buffSamples);
    refAcc.z = getCircBufMean(&circBuff->z, buffSamples);

    return refAcc;
}


void writeBuff(CircBuff **circBuff, Acc acc)
{
    CircBuff *_circBuff = NULL;

    writeCircBuf(&_circBuff->x, acc.x);
    writeCircBuf(&_circBuff->y, acc.y);
    writeCircBuf(&_circBuff->z, acc.z);

    *circBuff = _circBuff;
}


void btnCheck(uint8_t *unitState, CircBuff *circBuff, RefAcc *refAcc, uint8_t buffSamples)
{
    if (checkButton(UP) == PUSHED) {
        *unitState++;
        if (*unitState == 3) *unitState = 0;
    } else if (checkButton(DOWN) == PUSHED) 
        *refAcc = buffMean(circBuff, *refAcc, buffSamples);
}


Acc accUpdate(Acc acc, uint32_t *accSamples, uint32_t state)
{
    // Update the display
    switch (state) {
    case MPSS:
        acc.x = acc.x * GRAVITY;
        acc.y = acc.y * GRAVITY;
        acc.z = acc.z * GRAVITY;
    case G:
        acc.x = acc.x * 100 / ACCEL_SENSITVITY;
        acc.y = acc.y * 100 / ACCEL_SENSITVITY;
        acc.z = acc.z * 100 / ACCEL_SENSITVITY;
        displayMeanValf(acc.x, acc.y, acc.z, *++accSamples);
    break;
    case RAW:
        displayMeanVal(acc.x, acc.y, acc.z, *++accSamples);
    }

    return acc;
}  



// return refAcc
RefAcc meanUpdate(CircBuff *circBuff, RefAcc refAcc, uint32_t accSamples, uint8_t buffSamples)
{
    // to fulfil milestone 1: 1.2
    // Regularly update mean values 
    buffMean(circBuff, refAcc, buffSamples);

    // Update ref acc every BUF_SIZE
    if (accSamples % BUF_SIZE == 0 && accSamples >= BUF_SIZE) {
        // Set the reference values when the circular buffer is full
        // This is not done when the program is initiated, because
        // there would be no values to calculate a mean from
        refAcc = buffMean(circBuff, refAcc, buffSamples);
    }

    return refAcc;
}


void updateDisplay(CircBuff *circBuff, Acc acc, RefAcc *refAcc, uint32_t accSamples, uint8_t unitState, uint8_t *buffSamples)
{
    slowTick = false;

    // Read from the accelerometer and write the values to the buffers
    getAccelData(&acc.x, &acc.y, &acc.z);

    writeBuff(&circBuff, acc);
    *buffSamples++;
    if (*buffSamples > BUF_SIZE) 
        *buffSamples = BUF_SIZE;

    accUpdate(acc, &accSamples, unitState);

    *refAcc = meanUpdate(circBuff, *refAcc, accSamples, *buffSamples);
}

// -----------------------------------------------------------------------------
//                              Executes the program                           
// -----------------------------------------------------------------------------
int main(void)
{
    // Store Accelerometer data
    Acc acc = {0};
    // int32_t accX = 0;
    // int32_t accY = 0;
    // int32_t accZ = 0;

    // Store reference values
    RefAcc refAcc = {0};
    // int32_t refAccX = 0;
    // int32_t refAccY = 0;
    // int32_t refAccZ = 0;

    uint32_t accSamples = 0;       // Number of samples taken
    uint8_t samplesBuffered = 0;   // Number of samples buffered

    uint8_t unitState = 0;         // Unit display state

    // Circular buffers for accelerations
    CircBuff circBuff = {0};
    // circBuf_t intBuffX = {0};
    // circBuf_t intBuffY = {0};
    // circBuf_t intBuffZ = {0};

    // init(&intBuffX, &intBuffY, &intBuffZ);
    init(&circBuff);

    // circBuf_t intBuffX = circBuff.x;
    // circBuf_t intBuffY = circBuff.y;
    // circBuf_t intBuffZ = circBuff.z;

    while (1) {


        if (checkButton(UP) == PUSHED) {
            unitState++;
            if (unitState == 3) unitState = 0;
        } else if (checkButton(DOWN) == PUSHED) 
            refAcc = buffMean(&circBuff, refAcc, samplesBuffered);

        // btnCheck(&unitState, &circBuff, &refAcc, samplesBuffered);

        
        if (slowTick) {

            updateDisplay(&circBuff, acc, &refAcc, accSamples, unitState, &samplesBuffered);
            // slowTick = false;

            // // Read from the accelerometer and write the values to the buffers
            // getAccelData(&acc.x, &acc.y, &acc.z);

            // writeBuff(&circBuff, acc);
            // samplesBuffered++;
            // if (samplesBuffered > BUF_SIZE) {
            //     samplesBuffered = BUF_SIZE;
            // }

 
            // accUpdate(&acc, &accSamples, unitState);

            // Update the display
            // switch (unitState) {
            // case MPSS:
            //     acc.x = acc.x * GRAVITY;
            //     acc.y = acc.y * GRAVITY;
            //     acc.z = acc.z * GRAVITY;
            // case G:
            //     acc.x = acc.x * 100 / ACCEL_SENSITVITY;
            //     acc.y = acc.y * 100 / ACCEL_SENSITVITY;
            //     acc.z = acc.z * 100 / ACCEL_SENSITVITY;
            //     displayMeanValf(acc.x, acc.y, acc.z, ++accSamples);
            // break;
            // case RAW:
            //     displayMeanVal(acc.x, acc.y, acc.z, ++accSamples);
            // }

            // refAcc = meanUpdate(&circBuff, refAcc, accSamples, samplesBuffered);

            // // to fulfil milestone 1: 1.2
            // // Regularly update mean values 
            // buffMean(&circBuff, refAcc, samplesBuffered);

            // // Update ref acc every BUF_SIZE
            // if ((accSamples) % BUF_SIZE == 0 && accSamples >= BUF_SIZE) {
            //     // Set the reference values when the circular buffer is full
            //     // This is not done when the program is initiated, because
            //     // there would be no values to calculate a mean from
            //     refAcc = buffMean(&circBuff, refAcc, samplesBuffered);
            // }
        }
    }
}

